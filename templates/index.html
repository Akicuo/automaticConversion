{% extends "base.html" %}

{% block content %}
<div style="max-width: 800px; margin: 0 auto; padding-top: 2rem;">

    <!-- Request Section (Visible to all) -->
    <div style="margin-bottom: 3rem;">
        <h2 style="font-weight: 400; font-size: 1.2rem; margin-bottom: 1rem; color: var(--text-secondary);">
            {% if role == 'admin' %}Start Conversion{% else %}Request Conversion{% endif %}
        </h2>
        <div class="glass-panel" style="padding: 0.5rem; display: flex; align-items: center; position: relative;">
            <input type="text" id="modelSearch" placeholder="Search HuggingFace models..." autocomplete="off"
                style="flex-grow: 1; border: none; background: transparent; padding: 1rem; font-size: 1rem; color: var(--text-primary); outline: none;">
            {% if role == 'admin' %}
            <button class="primary" onclick="convertModel()" style="margin: 0.5rem;">Start</button>
            {% else %}
            <button class="primary" onclick="requestModel()" style="margin: 0.5rem;">Request</button>
            {% endif %}

            <div id="suggestions" class="glass-panel"
                style="position: absolute; top: 100%; left: 0; right: 0; max-height: 200px; overflow-y: auto; display: none; margin-top: 0.25rem; background: #050505; z-index: 20;">
            </div>
        </div>
        {% if role == 'admin' %}
        <div style="margin-top: 1rem;">
            <label
                style="display: flex; align-items: center; gap: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">
                <input type="checkbox" id="validationCheck" checked style="accent-color: var(--text-primary);">
                Validate disk space
            </label>
        </div>
        {% endif %}
    </div>

    <!-- Admin: Pending Requests -->
    {% if role == 'admin' %}
    <div style="margin-bottom: 3rem;">
        <h2 style="font-weight: 400; font-size: 1.2rem; margin-bottom: 1.5rem; color: var(--text-secondary);">Pending
            Requests</h2>
        <div id="requests-list" style="display: grid; gap: 0.75rem;">
            <div
                style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">
                Loading...</div>
        </div>
    </div>

    <!-- Admin: Active Discussions -->
    <div style="margin-bottom: 3rem;">
        <h2 style="font-weight: 400; font-size: 1.2rem; margin-bottom: 1.5rem; color: var(--text-secondary);">Active
            Discussions</h2>
        <div id="tickets-list" style="display: grid; gap: 0.75rem;">
            <div
                style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">
                Loading...</div>
        </div>
    </div>
    {% endif %}

    <!-- My Requests (Visible to logged-in users) -->
    {% if user and role != 'admin' %}
    <div style="margin-bottom: 3rem;">
        <h2 style="font-weight: 400; font-size: 1.2rem; margin-bottom: 1.5rem; color: var(--text-secondary);">My
            Requests</h2>
        <div id="my-requests-list" style="display: grid; gap: 0.75rem;">
            <div
                style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">
                Loading...</div>
        </div>
    </div>
    {% endif %}

    <!-- Status Board -->
    <div>
        <h2 style="font-weight: 400; font-size: 1.2rem; margin-bottom: 1.5rem; color: var(--text-secondary);">Conversion
            Queue</h2>
        <div id="models-list" style="display: grid; gap: 1rem;">
            <div
                style="text-align: center; color: var(--text-secondary); padding: 2rem; border: 1px dashed var(--glass-border); border-radius: 8px;">
                No active conversions.</div>
        </div>
    </div>
</div>

<template id="model-card-template">
    <div class="model-card glass-panel" data-model-id="" style="padding: 1.5rem; transition: border-color 0.2s;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <h3 class="model-name" style="margin: 0; font-size: 1rem; font-weight: 500;">Model Name</h3>
            <div style="display: flex; align-items: center; gap: 0.75rem;">
                <span class="status-badge"
                    style="font-family: monospace; letter-spacing: 0.05em; font-size: 0.75rem;">Status</span>
                <button class="terminate-btn"
                    style="display: none; background: transparent; color: #ff8c00; border: 1px solid #ff8c00; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">Terminate</button>
                <button class="delete-btn"
                    style="display: none; background: transparent; color: var(--error); border: 1px solid var(--error); padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">Delete</button>
            </div>
        </div>
        <div class="progress-bar-bg"
            style="background: rgba(255,255,255,0.05); height: 2px; width: 100%; margin-bottom: 1rem;">
            <div class="progress-bar-fill"
                style="background: var(--text-primary); height: 100%; width: 0%; transition: width 0.5s ease;"></div>
        </div>
        <div class="logs"
            style="font-family: 'Consolas', 'Monaco', monospace; font-size: 0.75rem; color: #a0e0a0; background: #0a0a0a; padding: 1rem; border-radius: 6px; height: 200px; overflow-y: auto; white-space: pre-wrap; line-height: 1.5;">
        </div>
        <div class="error-section"
            style="display: none; margin-top: 1rem; padding: 0.75rem; background: rgba(255,68,68,0.1); border-radius: 4px; font-size: 0.8rem; color: var(--error);">
        </div>
    </div>
</template>

<template id="request-card-template">
    <div class="request-card glass-panel" style="padding: 1rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div>
                <span class="request-model" style="font-weight: 500;"></span>
                <span class="request-by"
                    style="color: var(--text-secondary); font-size: 0.85rem; margin-left: 0.5rem;"></span>
            </div>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
                <button class="approve-btn"
                    style="background: var(--success); color: #000; border: none; padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Approve</button>
                <button class="discuss-btn"
                    style="background: transparent; color: #60a5fa; border: 1px solid #60a5fa; padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Discuss</button>
                <button class="reject-btn"
                    style="background: transparent; color: var(--error); border: 1px solid var(--error); padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">Reject</button>
            </div>
        </div>
        <div class="decline-reason-row" style="display: flex; gap: 0.5rem; align-items: center;">
            <input type="text" class="decline-reason-input" placeholder="Message (for discussion or decline reason)..."
                style="flex: 1; background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border); padding: 0.5rem; border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;">
        </div>
    </div>
</template>

<template id="my-request-card-template">
    <div class="my-request-card glass-panel" style="padding: 1rem;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <span class="request-model" style="font-weight: 500;"></span>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
                <span class="request-status" style="font-family: monospace; font-size: 0.75rem;"></span>
                <button class="view-ticket-btn"
                    style="display: none; background: transparent; color: #60a5fa; border: 1px solid #60a5fa; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">View
                    Thread</button>
            </div>
        </div>
        <div class="decline-reason"
            style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: rgba(255,68,68,0.1); border-radius: 4px; font-size: 0.85rem; color: var(--error);">
        </div>
    </div>
</template>

<template id="ticket-card-template">
    <div class="ticket-card glass-panel" style="padding: 1rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <div>
                <span class="ticket-model" style="font-weight: 500;"></span>
                <span class="ticket-by"
                    style="color: var(--text-secondary); font-size: 0.85rem; margin-left: 0.5rem;"></span>
            </div>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
                <span class="ticket-status"
                    style="font-family: monospace; font-size: 0.7rem; padding: 0.2rem 0.5rem; border-radius: 4px;"></span>
                <button class="ticket-view-btn"
                    style="background: transparent; color: #60a5fa; border: 1px solid #60a5fa; padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">Open</button>
                <button class="ticket-approve-btn"
                    style="background: var(--success); color: #000; border: none; padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">Approve</button>
                <button class="ticket-close-btn"
                    style="background: transparent; color: var(--error); border: 1px solid var(--error); padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">Close</button>
            </div>
        </div>
    </div>
</template>

{% endblock %}

{% block scripts %}
<script>
    const searchInput = document.getElementById('modelSearch');
    const suggestionsBox = document.getElementById('suggestions');
    const isAdmin = '{{ role }}' === 'admin';

    // Autocomplete
    if (searchInput) {
        let debounceTimer;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(debounceTimer);
            const query = e.target.value;
            if (query.length < 3) {
                suggestionsBox.style.display = 'none';
                return;
            }
            debounceTimer = setTimeout(() => fetchSuggestions(query), 300);
        });
    }

    async function fetchSuggestions(query) {
        try {
            const res = await fetch(`/api/hf/search?q=${encodeURIComponent(query)}`);
            const data = await res.json();

            suggestionsBox.innerHTML = '';
            if (data && data.length > 0) {
                data.forEach(model => {
                    const div = document.createElement('div');
                    div.textContent = model.id;
                    div.style.padding = '1rem';
                    div.style.cursor = 'pointer';
                    div.style.transition = 'background 0.2s';
                    div.onmouseover = () => div.style.background = 'rgba(255,255,255,0.05)';
                    div.onmouseout = () => div.style.background = 'transparent';
                    div.onclick = () => {
                        searchInput.value = model.id;
                        suggestionsBox.style.display = 'none';
                    };
                    suggestionsBox.appendChild(div);
                });
                suggestionsBox.style.display = 'block';
            } else {
                suggestionsBox.style.display = 'none';
            }
        } catch (e) {
            console.error(e);
        }
    }

    async function convertModel() {
        const modelId = searchInput.value;
        if (!modelId) return;

        try {
            const res = await fetch('/api/models/process', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model_id: modelId })
            });
            if (res.ok) {
                searchInput.value = '';
                fetchStatus();
            } else {
                const err = await res.json();
                alert('Error: ' + err.detail);
            }
        } catch (e) {
            alert('Failed to start process');
        }
    }

    async function requestModel() {
        const modelId = searchInput.value;
        if (!modelId) return;

        try {
            const res = await fetch('/api/requests/submit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ hf_repo_id: modelId })
            });
            const data = await res.json();
            alert(data.message);
            searchInput.value = '';
        } catch (e) {
            alert('Failed to submit request');
        }
    }

    async function fetchStatus() {
        try {
            const res = await fetch('/api/status/all');
            const models = await res.json();
            renderModels(models);
        } catch (e) { console.error(e); }
    }

    // Store scroll positions for each model's log panel
    const logScrollPositions = {};

    // Track if user is actively scrolling (to avoid auto-scroll to bottom)
    const userScrolling = {};

    function renderModels(models) {
        const container = document.getElementById('models-list');
        const template = document.getElementById('model-card-template');

        if (!models || models.length === 0) {
            container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 2rem; border: 1px dashed var(--glass-border); border-radius: 8px;">No active conversions.</div>';
            return;
        }

        // Clean up empty state message if present
        const emptyMsg = container.querySelector('div[style*="text-align: center"]');
        if (emptyMsg) emptyMsg.remove();

        // 1. Mark all existing cards as stale initially
        const existingCards = new Map();
        container.querySelectorAll('.model-card').forEach(card => {
            existingCards.set(card.dataset.modelId, card);
        });

        // 2. Process models
        models.forEach(model => {
            let card = existingCards.get(model.id);
            let logsEl;
            let shouldAutoScroll = true;

            if (card) {
                // Remove from stale list (it's active)
                existingCards.delete(model.id);

                logsEl = card.querySelector('.logs');
                // Check if user is at bottom BEFORE update
                const tolerance = 50; // pixels
                shouldAutoScroll = (logsEl.scrollHeight - logsEl.scrollTop - logsEl.clientHeight) <= tolerance;
            } else {
                // Create new card
                const clone = template.content.cloneNode(true);
                card = clone.querySelector('.model-card');
                card.dataset.modelId = model.id;
                container.appendChild(clone);
                logsEl = card.querySelector('.logs');
            }

            // Update content
            card.querySelector('.model-name').textContent = model.hf_repo_id;

            const badge = card.querySelector('.status-badge');
            badge.textContent = model.status.toUpperCase();

            if (model.status === 'error') badge.style.color = 'var(--error)';
            else if (model.status === 'complete') badge.style.color = 'var(--success)';
            else if (model.status === 'terminated') badge.style.color = '#ff8c00';
            else if (model.status === 'interrupted') badge.style.color = '#fbbf24';
            else badge.style.color = ''; // Default color

            // Progress
            card.querySelector('.progress-bar-fill').style.width = `${model.progress}%`;

            // Logs
            if (logsEl.textContent !== model.log) {
                logsEl.textContent = model.log;
                if (shouldAutoScroll) {
                    logsEl.scrollTop = logsEl.scrollHeight;
                }
            }

            // Error details
            const errorSection = card.querySelector('.error-section');
            if (model.error_details) {
                errorSection.style.display = 'block';
                if (errorSection.textContent !== model.error_details.slice(0, 500)) {
                    errorSection.textContent = model.error_details.slice(0, 500);
                }
            } else {
                errorSection.style.display = 'none';
            }

            // Delete button setup
            if (isAdmin) {
                const deleteBtn = card.querySelector('.delete-btn');
                const terminateBtn = card.querySelector('.terminate-btn');

                // Update click handlers
                deleteBtn.onclick = () => deleteModel(model.id, model.hf_repo_id);
                terminateBtn.onclick = () => terminateModel(model.id, model.hf_repo_id);

                // Show terminate for running jobs
                const runningStatuses = ['pending', 'initializing', 'downloading', 'converting', 'quantizing', 'uploading'];
                if (runningStatuses.includes(model.status)) {
                    terminateBtn.style.display = 'inline-block';
                    deleteBtn.style.display = 'none';
                } else if (model.status === 'error' || model.status === 'complete' || model.status === 'terminated' || model.status === 'interrupted') {
                    terminateBtn.style.display = 'none';
                    deleteBtn.style.display = 'inline-block';
                } else {
                    terminateBtn.style.display = 'none';
                    deleteBtn.style.display = 'none';
                }
            }
        });

        // 3. Remove stale cards
        existingCards.forEach(card => card.remove());
    }

    async function deleteModel(modelId, modelName) {
        if (!confirm(`Delete job for "${modelName}"?`)) return;

        try {
            const res = await fetch(`/api/models/${modelId}`, { method: 'DELETE' });
            if (res.ok) {
                fetchStatus();
            } else {
                const err = await res.json();
                alert('Failed to delete: ' + err.detail);
            }
        } catch (e) {
            alert('Failed to delete model');
        }
    }

    async function terminateModel(modelId, modelName) {
        if (!confirm(`Terminate running job for "${modelName}"?\n\nThis will stop the current processing immediately.`)) return;

        try {
            const res = await fetch(`/api/models/${modelId}/terminate`, { method: 'POST' });
            const data = await res.json();
            if (res.ok) {
                alert(data.message || 'Termination signal sent.');
                fetchStatus();
            } else {
                alert('Failed to terminate: ' + (data.detail || 'Unknown error'));
            }
        } catch (e) {
            alert('Failed to terminate model');
        }
    }

    // Requests (Admin only)
    async function fetchRequests() {
        if (!isAdmin) return;
        const container = document.getElementById('requests-list');
        if (!container) return;

        try {
            const res = await fetch('/api/requests/all');
            if (!res.ok) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">No pending requests.</div>';
                return;
            }
            const requests = await res.json();
            renderRequests(requests.filter(r => r.status === 'pending'));
        } catch (e) {
            console.error(e);
            container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">No pending requests.</div>';
        }
    }

    function renderRequests(requests) {
        const container = document.getElementById('requests-list');
        if (!container) return;

        const template = document.getElementById('request-card-template');

        container.innerHTML = '';

        if (requests.length === 0) {
            container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">No pending requests.</div>';
            return;
        }

        requests.forEach(req => {
            const clone = template.content.cloneNode(true);
            const card = clone.querySelector('.request-card');

            clone.querySelector('.request-model').textContent = req.hf_repo_id;
            clone.querySelector('.request-by').textContent = `by ${req.requested_by}`;

            const declineInput = clone.querySelector('.decline-reason-input');

            clone.querySelector('.approve-btn').onclick = async () => {
                await fetch(`/api/requests/${req.id}/approve`, { method: 'POST' });
                fetchRequests();
                fetchStatus();
            };

            clone.querySelector('.reject-btn').onclick = async () => {
                const reason = declineInput ? declineInput.value : '';
                await fetch(`/api/requests/${req.id}/reject`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ reason: reason })
                });
                fetchRequests();
            };

            clone.querySelector('.discuss-btn').onclick = async () => {
                const message = declineInput ? declineInput.value : '';
                try {
                    const res = await fetch('/api/tickets/create', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ request_id: req.id, initial_message: message })
                    });
                    const data = await res.json();
                    if (res.ok) {
                        alert(`Discussion thread created! Ticket #${data.ticket_id}`);
                        fetchRequests();
                        fetchTickets();
                    } else {
                        alert('Failed to create discussion: ' + (data.detail || 'Unknown error'));
                    }
                } catch (e) {
                    alert('Failed to create discussion thread');
                }
            };

            container.appendChild(clone);
        });
    }

    // Admin Tickets
    async function fetchTickets() {
        if (!isAdmin) return;
        const container = document.getElementById('tickets-list');
        if (!container) return;

        try {
            const res = await fetch('/api/tickets/all');
            if (!res.ok) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">No active discussions.</div>';
                return;
            }
            const tickets = await res.json();
            renderTickets(tickets.filter(t => t.status === 'open'));
        } catch (e) {
            console.error(e);
            container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">No active discussions.</div>';
        }
    }

    function renderTickets(tickets) {
        const container = document.getElementById('tickets-list');
        if (!container) return;

        const template = document.getElementById('ticket-card-template');

        container.innerHTML = '';

        if (tickets.length === 0) {
            container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">No active discussions.</div>';
            return;
        }

        tickets.forEach(ticket => {
            const clone = template.content.cloneNode(true);

            clone.querySelector('.ticket-model').textContent = ticket.hf_repo_id;
            clone.querySelector('.ticket-by').textContent = `by ${ticket.requested_by}`;

            const statusBadge = clone.querySelector('.ticket-status');
            statusBadge.textContent = ticket.status.toUpperCase();
            if (ticket.status === 'open') {
                statusBadge.style.background = 'rgba(96, 165, 250, 0.2)';
                statusBadge.style.color = '#60a5fa';
            } else {
                statusBadge.style.background = 'rgba(255,255,255,0.1)';
                statusBadge.style.color = 'var(--text-secondary)';
            }

            // View button - opens modal
            clone.querySelector('.ticket-view-btn').onclick = () => {
                currentTicketId = ticket.id;
                showTicketModal(ticket.id);
            };

            // Approve button - approve the request and close ticket
            clone.querySelector('.ticket-approve-btn').onclick = async () => {
                if (!confirm(`Approve conversion for "${ticket.hf_repo_id}"?`)) return;
                try {
                    // Use single approve endpoint that handles everything
                    const res = await fetch(`/api/tickets/${ticket.id}/approve`, { method: 'POST' });
                    if (res.ok) {
                        fetchTickets();
                        fetchRequests();
                        fetchStatus();
                    } else {
                        const data = await res.json();
                        alert('Failed to approve: ' + (data.detail || 'Unknown error'));
                    }
                } catch (e) {
                    alert('Failed to approve');
                }
            };

            // Close button - closes ticket as rejected
            clone.querySelector('.ticket-close-btn').onclick = async () => {
                if (!confirm(`Close discussion and reject request for "${ticket.hf_repo_id}"?`)) return;
                try {
                    await fetch(`/api/tickets/${ticket.id}/close`, { method: 'POST' });
                    fetchTickets();
                } catch (e) {
                    alert('Failed to close ticket');
                }
            };

            container.appendChild(clone);
        });
    }

    // My Requests (For logged-in users)
    const isLoggedIn = '{{ user }}' !== 'None' && '{{ user }}' !== '';

    async function fetchMyRequests() {
        if (isAdmin || !isLoggedIn) return;
        const container = document.getElementById('my-requests-list');
        if (!container) return;

        try {
            const res = await fetch('/api/requests/my');
            if (!res.ok) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">No requests yet.</div>';
                return;
            }
            const requests = await res.json();
            renderMyRequests(requests);
        } catch (e) {
            console.error(e);
            container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">No requests yet.</div>';
        }
    }

    function renderMyRequests(requests) {
        const container = document.getElementById('my-requests-list');
        if (!container) return;

        const template = document.getElementById('my-request-card-template');

        container.innerHTML = '';

        if (requests.length === 0) {
            container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 1.5rem; border: 1px dashed var(--glass-border); border-radius: 8px; font-size: 0.9rem;">No requests yet.</div>';
            return;
        }

        requests.forEach(req => {
            const clone = template.content.cloneNode(true);
            const card = clone.querySelector('.my-request-card');

            clone.querySelector('.request-model').textContent = req.hf_repo_id;

            const statusBadge = clone.querySelector('.request-status');
            statusBadge.textContent = req.status.toUpperCase();

            if (req.status === 'approved') {
                statusBadge.style.color = 'var(--success)';
            } else if (req.status === 'rejected') {
                statusBadge.style.color = 'var(--error)';
            } else if (req.status === 'discussion') {
                statusBadge.style.color = '#60a5fa';
            } else {
                statusBadge.style.color = 'var(--text-secondary)';
            }

            // Show View Thread button for discussion status
            const viewTicketBtn = clone.querySelector('.view-ticket-btn');
            if (req.status === 'discussion') {
                viewTicketBtn.style.display = 'inline-block';
                viewTicketBtn.onclick = () => openTicketModal(req.id);
            }

            // Show decline reason if rejected
            if (req.status === 'rejected' && req.decline_reason) {
                const declineDiv = clone.querySelector('.decline-reason');
                declineDiv.style.display = 'block';
                declineDiv.innerHTML = '<strong>Reason:</strong> ' + req.decline_reason;
            }

            container.appendChild(clone);
        });
    }

    // ====== TICKET MODAL SYSTEM ======
    let currentTicketId = null;

    async function openTicketModal(requestId) {
        // First get the ticket for this request
        try {
            const res = await fetch(`/api/tickets/request/${requestId}`);
            const data = await res.json();

            if (!data.ticket) {
                alert('No discussion thread found for this request.');
                return;
            }

            currentTicketId = data.ticket.id;
            showTicketModal(currentTicketId);
        } catch (e) {
            console.error(e);
            alert('Failed to load discussion thread');
        }
    }

    function showTicketModal(ticketId) {
        // Create modal if it doesn't exist
        let modal = document.getElementById('ticket-modal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'ticket-modal';
            modal.innerHTML = `
                <div class="ticket-modal-backdrop" onclick="closeTicketModal()" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 100;"></div>
                <div class="ticket-modal-content glass-panel" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; max-width: 90vw; max-height: 80vh; z-index: 101; padding: 1.5rem; display: flex; flex-direction: column;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h3 id="ticket-title" style="margin: 0; font-size: 1.1rem;">Discussion Thread</h3>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <button id="ticket-reopen-btn" onclick="reopenTicket()" style="display: none; background: transparent; color: #60a5fa; border: 1px solid #60a5fa; padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer; font-size: 0.75rem;">Reopen</button>
                            <button onclick="closeTicketModal()" style="background: transparent; color: var(--text-secondary); border: none; cursor: pointer; font-size: 1.2rem;">&times;</button>
                        </div>
                    </div>
                    <div id="ticket-messages" style="flex: 1; overflow-y: auto; border: 1px solid var(--glass-border); border-radius: 6px; padding: 1rem; margin-bottom: 1rem; background: rgba(0,0,0,0.3); max-height: 300px;">
                        <div style="text-align: center; color: var(--text-secondary);">Loading...</div>
                    </div>
                    <div id="ticket-reply-section" style="display: flex; gap: 0.5rem;">
                        <input type="text" id="ticket-reply-input" placeholder="Type your message..." style="flex: 1; background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border); padding: 0.75rem; border-radius: 6px; color: var(--text-primary);">
                        <button onclick="sendTicketReply()" class="primary" style="padding: 0.75rem 1.25rem;">Send</button>
                    </div>
                    <div id="ticket-closed-notice" style="display: none; text-align: center; color: var(--text-secondary); padding: 0.75rem; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 0.9rem;">
                        This thread is closed. <a href="#" onclick="reopenTicket(); return false;" style="color: #60a5fa;">Reopen to reply</a>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        modal.style.display = 'block';
        loadTicketMessages(ticketId);
    }

    function closeTicketModal() {
        const modal = document.getElementById('ticket-modal');
        if (modal) {
            modal.style.display = 'none';
        }
        currentTicketId = null;
    }

    async function loadTicketMessages(ticketId) {
        const messagesContainer = document.getElementById('ticket-messages');

        try {
            const res = await fetch(`/api/tickets/${ticketId}/messages`);
            const data = await res.json();

            // Update title
            document.getElementById('ticket-title').textContent = `Discussion: ${data.request.hf_repo_id}`;

            // Handle closed status
            const replySection = document.getElementById('ticket-reply-section');
            const closedNotice = document.getElementById('ticket-closed-notice');
            const reopenBtn = document.getElementById('ticket-reopen-btn');

            if (data.ticket.status === 'closed') {
                replySection.style.display = 'none';
                closedNotice.style.display = 'block';
                reopenBtn.style.display = 'inline-block';
            } else {
                replySection.style.display = 'flex';
                closedNotice.style.display = 'none';
                reopenBtn.style.display = 'none';
            }

            // Render messages
            if (data.messages.length === 0) {
                messagesContainer.innerHTML = '<div style="text-align: center; color: var(--text-secondary);">No messages yet. Start the conversation!</div>';
                return;
            }

            messagesContainer.innerHTML = '';
            data.messages.forEach(msg => {
                const msgEl = document.createElement('div');
                msgEl.style.cssText = `margin-bottom: 0.75rem; padding: 0.75rem; border-radius: 6px; ${msg.sender_role === 'admin' ? 'background: rgba(96, 165, 250, 0.15); margin-left: 1rem;' : 'background: rgba(255,255,255,0.05); margin-right: 1rem;'}`;

                const time = new Date(msg.created_at).toLocaleString();
                msgEl.innerHTML = `
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem; font-size: 0.75rem; color: var(--text-secondary);">
                        <span style="font-weight: 500; color: ${msg.sender_role === 'admin' ? '#60a5fa' : 'var(--text-primary)'};">${msg.sender} ${msg.sender_role === 'admin' ? '(Admin)' : ''}</span>
                        <span>${time}</span>
                    </div>
                    <div style="font-size: 0.9rem;">${escapeHtml(msg.message)}</div>
                `;
                messagesContainer.appendChild(msgEl);
            });

            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

        } catch (e) {
            console.error(e);
            messagesContainer.innerHTML = '<div style="text-align: center; color: var(--error);">Failed to load messages</div>';
        }
    }

    async function sendTicketReply() {
        if (!currentTicketId) return;

        const input = document.getElementById('ticket-reply-input');
        const message = input.value.trim();
        if (!message) return;

        try {
            const res = await fetch(`/api/tickets/${currentTicketId}/reply`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: message })
            });

            if (res.ok) {
                input.value = '';
                loadTicketMessages(currentTicketId);
            } else {
                const data = await res.json();
                alert('Failed to send: ' + (data.detail || 'Unknown error'));
            }
        } catch (e) {
            alert('Failed to send message');
        }
    }

    async function reopenTicket() {
        if (!currentTicketId) return;

        try {
            const res = await fetch(`/api/tickets/${currentTicketId}/reopen`, { method: 'POST' });
            if (res.ok) {
                loadTicketMessages(currentTicketId);
                fetchMyRequests();
                fetchTickets();
            } else {
                const data = await res.json();
                alert('Failed to reopen: ' + (data.detail || 'Unknown error'));
            }
        } catch (e) {
            alert('Failed to reopen thread');
        }
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Handle Enter key in reply input
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.target.id === 'ticket-reply-input') {
            sendTicketReply();
        }
    });

    // ====== WEBSOCKET REAL-TIME UPDATES ======
    let ws = null;
    let wsReconnectAttempts = 0;
    const maxReconnectAttempts = 10;
    const reconnectDelay = 3000;

    function connectWebSocket() {
        // Determine WebSocket URL (ws:// or wss://)
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws?channel=models&channel=requests&channel=tickets&channel=my_requests`;

        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            console.log('WebSocket connected');
            wsReconnectAttempts = 0;
            // Initial data fetch on connect
            fetchStatus();
            fetchRequests();
            fetchMyRequests();
            fetchTickets();
        };

        ws.onmessage = (event) => {
            try {
                const msg = JSON.parse(event.data);
                handleWebSocketMessage(msg);
            } catch (e) {
                console.error('Failed to parse WebSocket message:', e);
            }
        };

        ws.onclose = (event) => {
            console.log('WebSocket closed:', event.code, event.reason);
            ws = null;
            // Attempt to reconnect
            if (wsReconnectAttempts < maxReconnectAttempts) {
                wsReconnectAttempts++;
                console.log(`Reconnecting WebSocket (attempt ${wsReconnectAttempts})...`);
                setTimeout(connectWebSocket, reconnectDelay);
            } else {
                console.error('Max WebSocket reconnect attempts reached. Falling back to polling.');
                startPollingFallback();
            }
        };

        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
        };

        // Send periodic pings to keep connection alive
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send('ping');
            }
        }, 30000);
    }

    function handleWebSocketMessage(msg) {
        const { channel, data } = msg;

        if (!data) return;

        switch (data.type) {
            case 'model_update':
                // Single model update - update just that model in the UI
                updateSingleModel(data.model);
                break;
            case 'models_list':
                // Full models list update
                renderModels(data.models);
                break;
            case 'requests_update':
                // Requests changed - refresh
                fetchRequests();
                break;
            case 'tickets_update':
                // Tickets changed - refresh
                fetchTickets();
                break;
            case 'my_requests_update':
                // User's requests changed - refresh
                fetchMyRequests();
                break;
            case 'pong':
                // Ping response - connection is alive
                break;
            default:
                console.log('Unknown WebSocket message type:', data.type);
        }
    }

    function updateSingleModel(model) {
        // Try to update existing model card, or trigger a full refresh
        const container = document.getElementById('models-list');
        const existingCard = container.querySelector(`.model-card[data-model-id="${model.id}"]`);

        if (existingCard) {
            // Update existing card
            existingCard.querySelector('.model-name').textContent = model.hf_repo_id;

            const badge = existingCard.querySelector('.status-badge');
            badge.textContent = model.status.toUpperCase();

            if (model.status === 'error') badge.style.color = 'var(--error)';
            else if (model.status === 'complete') badge.style.color = 'var(--success)';
            else if (model.status === 'terminated') badge.style.color = '#ff8c00';
            else if (model.status === 'interrupted') badge.style.color = '#fbbf24';
            else badge.style.color = '';

            existingCard.querySelector('.progress-bar-fill').style.width = `${model.progress}%`;

            const logsEl = existingCard.querySelector('.logs');
            const tolerance = 50;
            const shouldAutoScroll = (logsEl.scrollHeight - logsEl.scrollTop - logsEl.clientHeight) <= tolerance;

            if (logsEl.textContent !== model.log) {
                logsEl.textContent = model.log;
                if (shouldAutoScroll) {
                    logsEl.scrollTop = logsEl.scrollHeight;
                }
            }

            const errorSection = existingCard.querySelector('.error-section');
            if (model.error_details) {
                errorSection.style.display = 'block';
                errorSection.textContent = model.error_details.slice(0, 500);
            } else {
                errorSection.style.display = 'none';
            }

            // Update buttons visibility
            if (isAdmin) {
                const deleteBtn = existingCard.querySelector('.delete-btn');
                const terminateBtn = existingCard.querySelector('.terminate-btn');

                deleteBtn.onclick = () => deleteModel(model.id, model.hf_repo_id);
                terminateBtn.onclick = () => terminateModel(model.id, model.hf_repo_id);

                const runningStatuses = ['pending', 'initializing', 'downloading', 'converting', 'quantizing', 'uploading'];
                if (runningStatuses.includes(model.status)) {
                    terminateBtn.style.display = 'inline-block';
                    deleteBtn.style.display = 'none';
                } else if (['error', 'complete', 'terminated', 'interrupted'].includes(model.status)) {
                    terminateBtn.style.display = 'none';
                    deleteBtn.style.display = 'inline-block';
                } else {
                    terminateBtn.style.display = 'none';
                    deleteBtn.style.display = 'none';
                }
            }
        } else {
            // New model - fetch all to get proper ordering
            fetchStatus();
        }
    }

    function startPollingFallback() {
        console.log('Starting polling fallback...');
        setInterval(fetchStatus, 3000);
        setInterval(fetchRequests, 5000);
        setInterval(fetchMyRequests, 5000);
        setInterval(fetchTickets, 5000);
    }

    // Initialize WebSocket connection
    connectWebSocket();
</script>
{% endblock %}